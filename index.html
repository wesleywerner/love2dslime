<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>LÖVE SLIME by wesleywerner</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>LÖVE SLIME</h1>
        <h2>SLIME is a LÖVE library for creating point-and-click adventure games.</h2>

        <section id="downloads">
          <a href="https://github.com/wesleywerner/loveslime/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/wesleywerner/loveslime/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/wesleywerner/loveslime" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a id="slime" class="anchor" href="#slime" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SLIME</h1>

<p>SLIME is a point-and-click adventure game library for LÖVE. It is inspired by the <a href="https://opensludge.github.io/">SLUDGE game engine</a>.</p>

<p>The name is an acronym for "SLUDGE to LÖVE Inspired Mimicry Environment".</p>

<p><strong>Status:</strong> In Development<br>
<strong>Version:</strong> 0.1  </p>

<hr>

<ol>
<li><a href="#features">Features</a></li>
<li><a href="#thanks">Thanks</a></li>
<li>
<a href="#slime-api">API Reference</a>

<ol>
<li><a href="#notes">Notes and Terminology</a></li>
<li><a href="#stage-setup">Stage setup</a></li>
<li><a href="#callbacks">Callbacks</a></li>
<li><a href="#reset">Reset</a></li>
<li><a href="#backgrounds">Backgrounds</a></li>
<li><a href="#layers">Layers</a></li>
<li><a href="#actors">Actors</a></li>
<li><a href="#animations">Animations</a></li>
<li><a href="#hotspots">Hotspots</a></li>
<li><a href="#status">Status</a></li>
<li><a href="#drawing">Drawing</a></li>
<li><a href="#speech">Speech</a></li>
<li><a href="#bags">Bags</a></li>
<li><a href="#cursors">Cursors</a></li>
<li><a href="#settings">Settings</a></li>
</ol>
</li>
<li><a href="#code-snippets">Code Snippets</a></li>
<li><a href="#license">License</a></li>
</ol>

<hr>

<h1>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Features</h1>

<ul>
<li>Animated backgrounds</li>
<li>Actors with directional movement</li>
<li>Path finding movement</li>
<li>Status text</li>
<li>Hotspots</li>
<li>Actor Speech</li>
<li>Bags (inventory)</li>
</ul>

<h1>
<a id="thanks" class="anchor" href="#thanks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Thanks</h1>

<p>I want to thank these people for making use of their code:</p>

<ul>
<li>kikito, for your animation library, <a href="https://love2d.org/wiki/anim8">anim8</a>.</li>
<li>GloryFish, for your <a href="https://github.com/GloryFish/lua-astar">A* path finding</a> lua code.</li>
<li>Bresenham's Line Algorithm <a href="http://www.roguebasin.com/index.php?title=Bresenham%27s_Line_Algorithm#Lua">from roguebasin.com</a>
</li>
</ul>

<p>Thank you!</p>

<hr>

<h1>
<a id="slime-api" class="anchor" href="#slime-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SLIME API</h1>

<p>This API reference lists the available functionality of SLIME. You should read the <a href="https://github.com/wesleywerner/loveslime/blob/master/tutorial/tutorial.md">SLIME tutorial</a> to see an example how these are used.</p>

<p>To use SLIME simply <code>require</code>:</p>

<pre><code>slime = require ("slime")
</code></pre>

<h2>
<a id="notes" class="anchor" href="#notes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Notes</h2>

<ul>
<li>The cardinal directions are oriented so that <code>SOUTH</code> points to the bottom of your screen, and <code>NORTH</code> to the top. So an actor facing <code>SOUTH</code> is looking at the player.</li>
<li>Whenever an image is passed to SLIME, assume it is the filename of the image. The image data will be loaded for you.</li>
</ul>

<h2>
<a id="terminology" class="anchor" href="#terminology" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Terminology</h2>

<ul>
<li>Stage: A room or game screen.</li>
<li>Actors: Visible objects on the stage that may be animated or have static images, they can move around or be stationary.</li>
<li>Hotspots: Invisible areas on the stage that the player can interact with.</li>
<li>Floor: Defines where actors are able to walk.</li>
<li>Layers: Defines areas where actors can walk behind.</li>
<li>Bags: A short synonymn for inventory.</li>
</ul>

<h2>
<a id="stage-setup" class="anchor" href="#stage-setup" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stage setup</h2>

<p>To set up your stage for play you need to clear objects, load a background, set the floor, add any layers, actors and hotspots.</p>

<p>A basic stage setup might look like this:</p>

<pre><code>function setupStage ()
    slime:reset ()
    slime:background ("background.png")
    slime:layer ("background.png", "layer.png", 50)
    slime:floor ("floor.png")
    addActors ()
    addHotspots ()
    slime.callback = myStageCallback
end

function myStageCallback (event, object)
    if (event == "moved") then
        if (object.name == "ego") then
            -- The "ego" actor reached her destination.
            -- object is an instance of the actor.
        end
    end
    if (event == "interact") then
        if (object.name == "spoon") then
            -- An actor or hotspot was interacted with (you called slime:interact (x, y))
            -- object is an instance of the actor or hotspot.
        end
    end
end
</code></pre>

<h2>
<a id="callbacks" class="anchor" href="#callbacks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Callbacks</h2>

<p>These SLIME callbacks trigger on certain game events.</p>

<p><img src="api/func.png" alt="func"> <code>slime.callback (event, object)</code></p>

<p>This callback notifies you when an actor has moved, or the player interacts something.</p>

<p><strong>event</strong>:  </p>

<ul>
<li>moved: an actor was told to move and has reached their destination.</li>
<li>interact: an object was clicked on (via <code>interact (x, y)</code>).</li>
</ul>

<p><strong>object</strong>:  </p>

<p>The related actor or hotspot. When this is an actor from a "moved" event, you can access the <code>x/y</code> where the actor was told to move with:</p>

<pre><code>object.clickedX
object.clickedY
</code></pre>

<p>These may be different than the actor's actual <code>x</code> and <code>y</code> if the floor does not allow walking to the position exactly. In these cases the actor will try to get as close as possible, but you still want the clicked position to call the <code>interact (x, y)</code> function.</p>

<p><img src="api/func.png" alt="func"> <code>slime.inventoryChanged (bag)</code></p>

<p>This callback notifies you when a bag's content has changed. The name of the bag is passed.</p>

<p><img src="api/func.png" alt="func"> <code>slime.animationLooped (actor, key, counter)</code></p>

<p>Called when an actor's animation loops. </p>

<p><strong>actor</strong>:</p>

<p>This is the name of the actor whose animation has looped.</p>

<p><strong>key</strong>:</p>

<p>This is the key of the animation that looped.</p>

<p><strong>counter</strong>:</p>

<p>This is the number of times the animation has looped.</p>

<h2>
<a id="reset" class="anchor" href="#reset" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reset</h2>

<p><img src="api/func.png" alt="func"> <code>slime:reset ()</code></p>

<p>Clear the stage, actors and hotspots. Call this before setting up a new stage. Note that bags (inventories) are <em>not</em> cleared.</p>

<h2>
<a id="backgrounds" class="anchor" href="#backgrounds" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Backgrounds</h2>

<p><img src="api/func.png" alt="func"> <code>slime:background (backgroundfilename, [, delay])</code></p>

<p>Add a background to the stage. <code>delay</code> sets how many milliseconds to display the background if multiple backgrounds are loaded, and may be omitted if only one background is set.</p>

<p><img src="api/func.png" alt="func"> <code>slime:floor (floorfilename)</code></p>

<p>Set the floor where actors can walk. This is an image where black (<code>#000</code>) indicates non-walkable areas, and any other color for walkable.</p>

<h2>
<a id="layers" class="anchor" href="#layers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Layers</h2>

<p>Layers define areas of your background where actors can walk behind.</p>

<p><img src="api/func.png" alt="func"> <code>slime:layer (background, mask, baseline)</code></p>

<p>Add a walk-behind layer. The <code>background</code> is where to cut the layer from. The <code>mask</code> defines where to cut.</p>

<p>The mask is an image with black (<code>#000</code>) where there is no layer, or any other colour to indicate the hide-behind layer.</p>

<p>The <code>baseline</code> is the y-position a character needs to be behind in order to be hidden by the layer.</p>

<h2>
<a id="actors" class="anchor" href="#actors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Actors</h2>

<p>Actors are items on your stage that may move or talk, like people, animals or robots. They can also be inanimate objects that may not move or talk but are animated, like doors, toasters and computers.</p>

<p><img src="api/func.png" alt="func"> <code>slime:actor (name, x, y)</code></p>

<p>Adds an actor to the stage. The actor object is returned:</p>

<pre><code>local boss = slime:actor ("Big Boss", 100, 100)
boss.speechcolor = {255, 0, 0}     -- Set the speech color for this actor as {red, green, blue}
</code></pre>

<p><img src="api/func.png" alt="func"> <code>slime:removeActor (name)</code>  </p>

<p>Removes the actor named <code>name</code></p>

<p><img src="api/func.png" alt="func"> <code>actor:setImage (path)</code></p>

<p>Sets a static (non-animated) image as the actor's sprite.</p>

<p><img src="api/prop.png" alt="property"> <code>actor.nozbuffer</code></p>

<p>Set this property to <code>true</code> if this actor draws above all layers.</p>

<pre><code>boss.nozbuffer = true
</code></pre>

<h2>
<a id="animations" class="anchor" href="#animations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Animations</h2>

<p>You define animations on actor objects.</p>

<p><img src="api/func.png" alt="func"> <code>actor:tileset (path, {w, h})</code>  </p>

<p>Loads a tileset for the actor, and returns the object used to define animation frames. The <code>size</code> is the width and height of each frame.</p>

<pre><code>local tileset = ego:tileset("ego.png", {w=12, h=12})
</code></pre>

<p><img src="api/func.png" alt="func"> <code>{tileset}:define (key)</code>  </p>

<p>Defines a new animation on a tileset object. This returns the object used to define animation frames.</p>

<p><img src="api/func.png" alt="func"> <code>{animation}:frames (frames)</code><br>
<img src="api/func.png" alt="func"> <code>{animation}:delays (delays)</code>  </p>

<p>Sets the frames that make up an animation.</p>

<p>The format of the <code>frames</code> and <code>delays</code> follow the <a href="https://github.com/kikito/anim8">anim8 library</a> convention. I recommend you go over there to read about the Frames format.</p>

<pre><code>local tileset = ego:tileset("ego.png", {w=12, h=12})
local anim = tileset:define("walk south")
anim:frames({'1-5', 1)  -- frames 1 through 5 on the first row in the tileset
anim:delays(0.2)        -- 0.2 seconds delay for all frames
</code></pre>

<p>The animation object can chain calls for cleaner code:</p>

<pre><code>local tileset = ego:tileset("ego.png", {w=12, h=12})
tileset:define("walk south"):frames({'1-5', 1):delays(0.2)
tileset:define("walk north"):frames({'6-9', 1):delays(0.2)
</code></pre>

<p><img src="api/func.png" alt="func"> <code>{animation}:flip ()</code>  </p>

<p>You can mirror an animation:</p>

<pre><code>-- create an east facing animation by flipping west facing frames
tileset:define("walk west"):frames({'10-15', 1):delays(0.2)
tileset:define("walk east"):frames({'10-15', 1):delays(0.2):flip()
</code></pre>

<p><img src="api/func.png" alt="func"> <code>{animation}:sounds (sounds)</code>  </p>

<p>The <code>sounds</code> function takes an indexed table of sound sources, each sound plays when the corresponding frame position is drawn.</p>

<pre><code>-- play step.wav when frame 1 shows. Occurs every animation loop.
tileset:define("walk west")
    :frames({'10-15', 1)
    :delays(0.2)
    :sounds( {[1] = "step.wav"} )
</code></pre>

<p><img src="api/func.png" alt="func"> <code>{animation}:offset ({x, y})</code>  </p>

<p>The <code>offset</code> function takes <code>{x, y}</code> which displaces the drawing of frames. This is used in special cases when your actor has a certain animation with a different tileset size than it's normal frames. Switching to such an animtion makes the draw position jump since the center of the larger frames don't line up with the normal frames. Compensate for this variation with the offset.</p>

<p><img src="api/func.png" alt="func"> <code>slime:animationDuration(actor, key)</code>  </p>

<p>Returns the duration of an animation in seconds. This value is the sum of all frame delays on an animation, and totals to one loop of the animation.</p>

<h3>
<a id="special-animation-keys" class="anchor" href="#special-animation-keys" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Special Animation Keys</h3>

<p>Actor animations with these keys will automatically be used by the SLIME engine. The direction an actor faces can be south, west, east or north.
The actions that are special are:</p>

<ul>
<li>idle: The actor is not speaking or walking. They are idle.</li>
<li>walk: The actor is walking.</li>
<li>talk: The actor is speaking.</li>
</ul>

<p>Here is a sample of combinations of actor animation names that are picked up by SLIME:</p>

<ul>
<li>"idle north"</li>
<li>"walk east"</li>
<li>"talk south"</li>
</ul>

<p><img src="api/func.png" alt="func"> <code>slime:moveActor (name, x, y)</code></p>

<p>Move an actor. There has to be a valid floor set for movement to find a path.</p>

<p>Example:</p>

<pre><code>slime:moveActor("ego", 90, 34)
</code></pre>

<p><img src="api/func.png" alt="func"> <code>slime:moveActorTo (name, target)</code></p>

<p>Move an actor to another actor.</p>

<p><img src="api/func.png" alt="func"> <code>slime:turnActor (name, direction)</code></p>

<p>Turns an Actor to face a direction, one of <code>south</code>, <code>west</code>, <code>north</code> or <code>east</code>.</p>

<h2>
<a id="hotspots" class="anchor" href="#hotspots" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hotspots</h2>

<p><img src="api/func.png" alt="func"> <code>slime:hotspot (name, x, y, w, h)</code></p>

<p>Adds a hotspot to the stage.</p>

<p><img src="api/func.png" alt="func"> <code>slime:interact (x, y)</code></p>

<p>Interacts with all objects at <code>x, y</code>. This triggers an "interact" event in <code>slime.callback</code>.</p>

<p>Returns true if there are any objects at that position.</p>

<p><img src="api/func.png" alt="func"> <code>slime:getObjects (x, y)</code></p>

<p>Gets a table of objects under <code>x/y</code>, or <code>nil</code> if no object is found.</p>

<h2>
<a id="status" class="anchor" href="#status" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Status</h2>

<p><img src="api/func.png" alt="func"> <code>slime:status (text)</code></p>

<p>Set or unset the status bar text.</p>

<h2>
<a id="drawing" class="anchor" href="#drawing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Drawing</h2>

<p><img src="api/func.png" alt="func"> <code>slime:update (dt)</code></p>

<p>Update animated backgrounds, actor movements and animations.</p>

<p><img src="api/func.png" alt="func"> <code>slime:draw ([scale])</code></p>

<p>Draw the scene to the display. The <code>scale</code> parameter defaults to 1, and is only needed if you called <code>love.graphics.scale</code> before calling this function.</p>

<h2>
<a id="speech" class="anchor" href="#speech" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Speech</h2>

<p>You can queue multiple speeches at once, the actor animation will change to "talk" and the words will print on screen.</p>

<p><img src="api/func.png" alt="func"> <code>slime:say (name, words)</code></p>

<p>Make an actor say something.</p>

<p><img src="api/func.png" alt="func"> <code>slime:someoneTalking()</code></p>

<p>Returns <code>true</code> if there is speech displaying.</p>

<h2>
<a id="bags" class="anchor" href="#bags" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bags</h2>

<p>Bags are analogous to inventory. The bags system is very simple yet flexible: Each bag has a name and can hold multiple items. In this way it supports inventory for multiple actors.</p>

<p><img src="api/func.png" alt="func"> <code>slime:bagInsert (bag, object)</code></p>

<p>Inserts something into a bag.</p>

<ul>
<li>The name of the <code>bag</code> can be anything, but for clarity, using an actor's name is a sensible choice.</li>
<li>The <code>object</code> is a table with a <code>name</code> value. You can add your own values to the object too.</li>
</ul>

<p>Example:</p>

<pre><code>local theSpoon = { ["name"] = "spoon" }
slime:bagInsert ("ego", theSpoon)
</code></pre>

<p><img src="api/func.png" alt="func"> <code>slime:bagContents (bag)</code></p>

<p>Gets the contents of a bag as a table.</p>

<p><img src="api/func.png" alt="func"> <code>slime:bagRemove (bag, name)</code></p>

<p>Removes an item (<code>name</code>) from a <code>bag</code>.</p>

<p><img src="api/func.png" alt="func"> <code>slime:bagButton (name, image, x, y)</code></p>

<p>Add a hotspot with an image that draws on screen. </p>

<h2>
<a id="chains" class="anchor" href="#chains" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Chains</h2>

<p>Chains give you a way to script actor movement and dialogue in sequence. If your main actor needs to walk to a tree, says something witty, walk down to a pond and then jump in, chains allow you to script this.</p>

<p><img src="api/func.png" alt="func"> <code>slime:chain()</code>  </p>

<p>Creates and returns a new chain of events. Use this chain object to add the links to your chain. Links process in sequence, each waiting in turn until the one before it resolves.</p>

<p><img src="api/func.png" alt="func"> <code>chain:image (actor, path)</code>  </p>

<p>Calls <code>actor:setImage</code>. Resolves immediately.</p>

<p><img src="api/func.png" alt="func"> <code>chain:move (actor, position)</code>  </p>

<p>Calls <code>slime:moveActor</code> or <code>slime:moveActorTo</code>. Position may be a table of <code>{x, y}</code> or a string of another actor's name. Resolves when the given actor's movement path is emptied.</p>

<p>Also note that this fires the <code>slime.callback</code> event for "moved" as usual, that is to say, chained actions behave like the player performed them.</p>

<p><img src="api/func.png" alt="func"> <code>chain:turn (actor, direction)</code>  </p>

<p>Calls <code>slime:turnActor</code>. Resolves immediately.</p>

<p><img src="api/func.png" alt="func"> <code>chain:wait (duration)</code>  </p>

<p>Waits at this link for a duration of seconds.</p>

<p><img src="api/func.png" alt="func"> <code>chain:anim (actor, key [,wait])</code>  </p>

<p>Calls <code>slime:setAnimation</code>. Resolves immediately.</p>

<p>If <code>wait</code> is given as <code>true</code>, then the chain will wait for the duration of one animation loop.</p>

<p>For example, this code:</p>

<pre><code>chain:anim("ego", "throw dust")
chain:wait(slime:animationDuration("ego", "throw dust"))
</code></pre>

<p>gives the same result as this line:</p>

<pre><code>chain:anim("ego", "throw dust", true)
</code></pre>

<p><img src="api/func.png" alt="func"> <code>chain:floor (path)</code>  </p>

<p>Calls <code>slime:floor</code>. Resolves immediately.</p>

<p><img src="api/func.png" alt="func"> <code>chain:func (func, params)</code>  </p>

<p>Calls the function <code>func</code> with the given parameters. Resolves immediately.</p>

<p><img src="api/func.png" alt="func"> <code>chain:say (actor, words)</code>  </p>

<p>Calls <code>slime:say</code>. Resolves when the given actor is not busy speaking. If <code>slime:skipSpeech</code> is called while the actor is talking, then this link will be resolved.</p>

<p><img src="api/func.png" alt="func"> <code>chain:sound (source)</code></p>

<p>Plays the given audio source. Resolves immediately.</p>

<h3>
<a id="example-chain" class="anchor" href="#example-chain" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example Chain</h3>

<pre><code>local chain = slime:chain()
chain:move("ego", "light switch")
chain:anim("ego", "flip the switch")
chain:image("light", "light-on.png")
chain:sound(love.audio.newSource("sounds/switch.wav", "static"))
chain:say("ego", "Now I can see")
</code></pre>

<h2>
<a id="cursors" class="anchor" href="#cursors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cursors</h2>

<p><img src="api/func.png" alt="func"> <code>slime:setCursor (name, image, scale, hotx, hoty)</code></p>

<p>Set a hardware cursor with scale applied.</p>

<p>When you set a cursor, the <code>name</code> is passed back as the <code>event</code> parameter to <code>slime.callback</code>. This makes it easy to check if the player is using a key on a door.</p>

<p>Call with no parameters to set the default cursor.</p>

<h2>
<a id="settings" class="anchor" href="#settings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Settings</h2>

<p>SLIME offers these settings to customize your game:</p>

<pre><code>slime.settings["status position"] = 70      -- The Y position to print the built-in status text
slime.settings["status font"] = love.graphics.Font
slime.settings["speech position"] = 0       -- The Y position to print speech
slime.settings["speech font"] = love.graphics.Font
</code></pre>

<hr>

<h1>
<a id="code-snippets" class="anchor" href="#code-snippets" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CODE SNIPPETS</h1>

<h2>
<a id="flip-the-frames-on-a-custom-animation" class="anchor" href="#flip-the-frames-on-a-custom-animation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Flip the frames on a custom animation</h2>

<p>The <code>addAnimation</code> call returns the Anim8 object which has flip functions:</p>

<pre><code>local myanim = slime:addAnimation("ego", "dig", "images/ego.png", tileSize, tileSize, {"22-25", 1}, 0.2)
myanim:flipH()  -- flips horizontally
myanim:flipV()  -- flips vertically
</code></pre>

<h2>
<a id="one-shot-animations" class="anchor" href="#one-shot-animations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>One shot animations</h2>

<p>To animate an actor once, like an opening door, hook into the Animation Looped callback:</p>

<pre><code>function slime.animationLooped (actor, key, counter)

    -- Keep the door closed after the closing animation played.
    if actor == "door" and key == "closing" then
        slime:setAnimation ("door", "closed")
    end

end
</code></pre>

<p>Of course this assume you have added a "door" actor with the "closing" and "closed" custom animations.</p>

<hr>

<h1>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LICENSE</h1>

<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.</p>

<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License
along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
      </section>
    </div>

    
  </body>
</html>
