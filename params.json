{
  "name": "LÖVE SLIME",
  "tagline": "SLIME is a LÖVE library for creating point-and-click adventure games.",
  "body": "# SLIME\r\n\r\nSLIME is a point-and-click adventure game library for L&Ouml;VE. It is inspired by the [SLUDGE game engine](https://opensludge.github.io/).\r\n\r\nThe name is an acronym for \"SLUDGE to L&Ouml;VE Inspired Mimicry Environment\".\r\n\r\n**Status:** In Development  \r\n**Version:** 0.1  \r\n\r\n---\r\n\r\n1. [Features](#features)\r\n1. [Thanks](#thanks)\r\n1. [API Reference](#slime-api)\r\n    1. [Notes and Terminology](#notes)\r\n    1. [Stage setup](#stage-setup)\r\n    1. [Callbacks](#callbacks)\r\n    1. [Reset](#reset)\r\n    1. [Backgrounds](#backgrounds)\r\n    1. [Layers](#layers)\r\n    1. [Actors](#actors)\r\n    1. [Animations](#animations)\r\n    1. [Hotspots](#hotspots)\r\n    1. [Status](#status)\r\n    1. [Drawing](#drawing)\r\n    1. [Speech](#speech)\r\n    1. [Bags](#bags)\r\n    1. [Cursors](#cursors)\r\n    1. [Settings](#settings)\r\n1. [Code Snippets](#code-snippets)\r\n1. [License](#license)\r\n\r\n---\r\n\r\n# Features\r\n\r\n* Animated backgrounds\r\n* Actors with directional movement\r\n* Path finding movement\r\n* Status text\r\n* Hotspots\r\n* Actor Speech\r\n* Bags (inventory)\r\n\r\n**TODO**  \r\n\r\n* Document slime.setAnimation (self, name, key)\r\n* Tutorial\r\n* Tidy function parameter names\r\n\r\n# Thanks\r\n\r\nI want to thank these people for making use of their code:\r\n\r\n* kikito, for your animation library, [anim8](https://love2d.org/wiki/anim8).\r\n* GloryFish, for your [A* path finding](https://github.com/GloryFish/lua-astar) lua code.\r\n* Bresenham's Line Algorithm [from roguebasin.com](http://www.roguebasin.com/index.php?title=Bresenham%27s_Line_Algorithm#Lua)\r\n\r\nThank you!\r\n\r\n---\r\n\r\n# SLIME API\r\n\r\nThis API reference lists the available functionality of SLIME. You should read the [SLIME tutorial](https://github.com/wesleywerner/loveslime/blob/master/tutorial/tutorial.md) to see an example how these are used.\r\n\r\nTo use SLIME simply `require`:\r\n\r\n    slime = require (\"slime\")\r\n\r\n## Notes\r\n  \r\n* The cardinal directions are oriented so that `SOUTH` points to the bottom of your screen, and `NORTH` to the top. So an actor facing `SOUTH` is looking at the player.\r\n* Whenever an image is passed to SLIME, assume it is the filename of the image. The image data will be loaded for you.\r\n\r\n## Terminology\r\n\r\n* Stage: A room or game screen.\r\n* Actors: Visible objects on the stage that may be animated or have static images, they can move around or be stationary.\r\n* Hotspots: Invisible areas on the stage that the player can interact with.\r\n* Floor: Defines where actors are able to walk.\r\n* Layers: Defines areas where actors can walk behind.\r\n* Bags: A short synonymn for inventory.\r\n\r\n## Stage setup\r\n\r\nTo set up your stage for play you need to clear objects, load a background, set the floor, add any layers, actors and hotspots.\r\n\r\nA basic stage setup might look like this:\r\n\r\n    function setupStage ()\r\n        slime.reset ()\r\n        slime.background (\"background.png\")\r\n        slime.layer (\"background.png\", \"layer.png\", 50)\r\n        slime.floor (\"floor.png\")\r\n        addActors ()\r\n        addHotspots ()\r\n        slime.callback = myStageCallback\r\n    end\r\n\r\n    function myStageCallback (event, object)\r\n        if (event == \"moved\") then\r\n            if (object.name == \"ego\") then\r\n                -- The \"ego\" actor reached her destination.\r\n                -- object is an instance of the actor.\r\n            end\r\n        end\r\n        if (event == \"interact\") then\r\n            if (object.name == \"spoon\") then\r\n                -- An actor or hotspot was interacted with (you called slime:interact (x, y))\r\n                -- object is an instance of the actor or hotspot.\r\n            end\r\n        end\r\n    end\r\n\r\n## Callbacks\r\n\r\nThese SLIME callbacks trigger on certain game events.\r\n\r\n![func](api/func.png) `slime.callback (event, object)`\r\n\r\nThis callback notifies you when an actor has moved, or the player interacts something.\r\n\r\n**event**:  \r\n\r\n* moved: an actor was told to move and has reached their destination.\r\n* interact: an object was clicked on (via `interact (x, y)`).\r\n\r\n**object**:  \r\n\r\nThe related actor or hotspot. When this is an actor from a \"moved\" event, you can access the `x/y` where the actor was told to move with:\r\n\r\n    object.clickedX\r\n    object.clickedY\r\n\r\nThese may be different than the actor's actual `x` and `y` if the floor does not allow walking to the position exactly. In these cases the actor will try to get as close as possible, but you still want the clicked position to call the `interact (x, y)` function.\r\n\r\n![func](api/func.png) `slime.inventoryChanged (bag)`\r\n\r\nThis callback notifies you when a bag's content has changed. The name of the bag is passed.\r\n\r\n![func](api/func.png) `slime.animationLooped (actor, key, counter)`\r\n\r\nCalled when an actor's animation loops. \r\n\r\n**actor**:\r\n\r\nThis is the name of the actor whose animation has looped.\r\n\r\n**key**:\r\n\r\nThis is the key of the animation that looped.\r\n\r\n**counter**:\r\n\r\nThis is the number of times the animation has looped.\r\n\r\n## Reset\r\n\r\n![func](api/func.png) `slime.reset ()`\r\n\r\nClear the stage, actors and hotspots. Call this before setting up a new stage. Note that bags (inventories) are _not_ cleared.\r\n\r\n## Backgrounds\r\n\r\n![func](api/func.png) `slime.background (backgroundfilename, [, delay])`\r\n\r\nAdd a background to the stage. `delay` sets how many milliseconds to display the background if multiple backgrounds are loaded, and may be omitted if only one background is set.\r\n\r\n![func](api/func.png) `slime.floor (floorfilename)`\r\n\r\nSet the floor where actors can walk. This is an image where black (`#000`) indicates non-walkable areas, and any other color for walkable.\r\n\r\n## Layers\r\n\r\nLayers define areas of your background where actors can walk behind.\r\n\r\n![func](api/func.png) `slime.layer (background, mask, baseline)`\r\n\r\nAdd a walk-behind layer. The `background` is where to cut the layer from. The `mask` defines where to cut.\r\n\r\nThe mask is an image with black (`#000`) where there is no layer, or any other colour to indicate the hide-behind layer.\r\n\r\nThe `baseline` is the y-position a character needs to be behind in order to be hidden by the layer.\r\n\r\n## Actors\r\n\r\nActors are items on your stage that may move or talk, like people, animals or robots. They can also be inanimate objects that may not move or talk but are animated, like doors, toasters and computers.\r\n\r\n![func](api/func.png) `slime:actor (name, x, y)`\r\n\r\nAdds an actor to the stage. The actor object is returned:\r\n\r\n    local boss = slime.actor (\"Big Boss\", 100, 100)\r\n    boss.speechcolor = {255, 0, 0}     -- Set the speech color for this actor as {red, green, blue}\r\n\r\n![func](api/func.png) `slime:removeActor (name)`  \r\n\r\nRemoves the actor named `name`\r\n\r\n![func](api/func.png) `actor:setImage (path)`\r\n\r\nSets a static (non-animated) image as the actor's sprite.\r\n\r\n![property](api/prop.png) `actor.nozbuffer`\r\n\r\nSet this property to `true` if this actor draws above all layers.\r\n\r\n## Animations\r\n\r\nYou define animations on actor objects.\r\n\r\n![func](api/func.png) `actor:tileset (path, {w, h})`  \r\n\r\nLoads a tileset for the actor, and returns the object used to define animation frames. The `size` is the width and height of each frame.\r\n\r\n    local tileset = ego:tileset(\"ego.png\", {w=12, h=12})\r\n\r\n![func](api/func.png) `{tileset}:define (key)`  \r\n\r\nDefines a new animation on a tileset object. This returns the object used to define animation frames.\r\n\r\n![func](api/func.png) `{animation}:frames (frames)`  \r\n![func](api/func.png) `{animation}:delays (delays)`  \r\n\r\nSets the frames that make up an animation.\r\n\r\nThe format of the `frames` and `delays` follow the [anim8 library](https://github.com/kikito/anim8) convention. I recommend you go over there to read about the Frames format.\r\n\r\n    local tileset = ego:tileset(\"ego.png\", {w=12, h=12})\r\n    local anim = tileset:define(\"walk south\")\r\n    anim:frames({'1-5', 1)  -- frames 1 through 5 on the first row in the tileset\r\n    anim:delays(0.2)        -- 0.2 seconds delay for all frames\r\n\r\nThe animation object can chain calls for cleaner code:\r\n\r\n    local tileset = ego:tileset(\"ego.png\", {w=12, h=12})\r\n    tileset:define(\"walk south\"):frames({'1-5', 1):delays(0.2)\r\n    tileset:define(\"walk north\"):frames({'6-9', 1):delays(0.2)\r\n\r\n![func](api/func.png) `{animation}:flip ()`  \r\n\r\nYou can mirror an animation:\r\n\r\n    -- create an east facing animation by flipping west facing frames\r\n    tileset:define(\"walk west\"):frames({'10-15', 1):delays(0.2)\r\n    tileset:define(\"walk east\"):frames({'10-15', 1):delays(0.2):flip()\r\n\r\n![func](api/func.png) `{animation}:sounds (sounds)`  \r\n\r\nThe `sounds` function takes an indexed table of sound sources, each sound plays when the corresponding frame position is drawn.\r\n\r\n    -- play step.wav when frame 1 shows. Occurs every animation loop.\r\n    tileset:define(\"walk west\")\r\n        :frames({'10-15', 1)\r\n        :delays(0.2)\r\n        :sounds( {[1] = \"step.wav\"} )\r\n\r\n![func](api/func.png) `{animation}:offset ({x, y})`  \r\n\r\nThe `offset` function takes `{x, y}` which displaces the drawing of frames. This is used in special cases when your actor has a certain animation with a different tileset size than it's normal frames. Switching to such an animtion makes the draw position jump since the center of the larger frames don't line up with the normal frames. Compensate for this variation with the offset.\r\n\r\n![func](api/func.png) `slime:animationDuration(actor, key)`  \r\n\r\nReturns the duration of an animation in seconds. This value is the sum of all frame delays on an animation, and totals to one loop of the animation.\r\n\r\n### Special Animation Keys\r\n\r\nActor animations with these keys will automatically be used by the SLIME engine, where <direction> is replaced where the actor's facing, south, west, east or north.\r\n\r\n* \"idle south\": The actor is not speaking or walking. They are idle.\r\n* \"walk south\": The actor is moving.\r\n* \"talk south\": The actor is speaking.\r\n\r\n![func](api/func.png) `slime.moveActor (name, x, y)`\r\n\r\nMove an actor. There has to be a valid floor set for movement to find a path.\r\n\r\nExample:\r\n\r\n    slime.moveActor(\"ego\", 90, 34)\r\n    \r\n![func](api/func.png) `slime.moveActorTo (name, target)`\r\n\r\nMove an actor to another actor.\r\n\r\n![func](api/func.png) `slime.turnActor (name, direction)`\r\n\r\nTurns an Actor to face a direction, one of `south`, `west`, `north` or `east`.\r\n\r\n## Hotspots\r\n\r\n![func](api/func.png) `slime.hotspot (name, x, y, w, h)`\r\n\r\nAdds a hotspot to the stage.\r\n\r\n![func](api/func.png) `slime:interact (x, y)`\r\n\r\nInteracts with all objects at `x, y`. This triggers an \"interact\" event in `slime.callback`.\r\n\r\nReturns true if there are any objects at that position.\r\n\r\n![func](api/func.png) `slime.getObjects (x, y)`\r\n\r\nGets a table of objects under `x/y`, or `nil` if no object is found.\r\n\r\n## Status\r\n\r\n![func](api/func.png) `slime.status (text)`\r\n\r\nSet or unset the status bar text.\r\n\r\n## Drawing\r\n\r\n![func](api/func.png) `slime.update (dt)`\r\n\r\nUpdate animated backgrounds, actor movements and animations.\r\n\r\n![func](api/func.png) `slime.draw ([scale])`\r\n\r\nDraw the scene to the display. The `scale` parameter defaults to 1, and is only needed if you called `love.graphics.scale` before calling this function.\r\n\r\n## Speech\r\n\r\nYou can queue multiple speeches at once, the actor animation will change to \"talk\" and the words will print on screen.\r\n\r\n![func](api/func.png) `slime:say (name, words)`\r\n\r\nMake an actor say something.\r\n\r\n![func](api/func.png) `slime:someoneTalking()`\r\n\r\nReturns `true` if there is speech displaying.\r\n\r\n## Bags\r\n\r\nBags are analogous to inventory. The bags system is very simple yet flexible: Each bag has a name and can hold multiple items. In this way it supports inventory for multiple actors.\r\n\r\n![func](api/func.png) `slime.bagInsert (bag, object)`\r\n\r\nInserts something into a bag.\r\n\r\n* The name of the `bag` can be anything, but for clarity, using an actor's name is a sensible choice.\r\n* The `object` is a table with a `name` value. You can add your own values to the object too.\r\n\r\nExample:\r\n\r\n    local theSpoon = { [\"name\"] = \"spoon\" }\r\n    slime.bagInsert (\"ego\", theSpoon)\r\n\r\n![func](api/func.png) `slime.bagContents (bag)`\r\n\r\nGets the contents of a bag as a table.\r\n\r\n![func](api/func.png) `slime.bagRemove (bag, name)`\r\n\r\nRemoves an item (`name`) from a `bag`.\r\n\r\n![func](api/func.png) `slime.bagButton (name, image, x, y)`\r\n\r\nAdd a hotspot with an image that draws on screen. \r\n\r\n\r\n## Chains\r\n\r\nChains give you a way to script actor movement and dialogue in sequence. If your main actor needs to walk to a tree, says something witty, walk down to a pond and then jump in, chains allow you to script this.\r\n\r\n![func](api/func.png) `slime.chain()`  \r\n\r\nCreates and returns a new chain of events. Use this chain object to add the links to your chain. Links process in sequence, each waiting in turn until the one before it resolves.\r\n\r\n![func](api/func.png) `chain:image (actor, path)`  \r\n\r\nCalls `actor:setImage`. Resolves immediately.\r\n\r\n![func](api/func.png) `chain:move (actor, position)`  \r\n\r\nCalls `slime:moveActor` or `slime:moveActorTo`. Position may be a table of `{x, y}` or a string of another actor's name. Resolves when the given actor's movement path is emptied.\r\n\r\nAlso note that this fires the `slime.callback` event for \"moved\" as usual, that is to say, chained actions behave like the player performed them.\r\n\r\n![func](api/func.png) `chain:turn (actor, direction)`  \r\n\r\nCalls `slime:turnActor`. Resolves immediately.\r\n\r\n![func](api/func.png) `chain:wait (duration)`  \r\n\r\nWaits at this link for a duration of seconds.\r\n\r\n![func](api/func.png) `chain:anim (actor, key [,wait])`  \r\n\r\nCalls `slime:setAnimation`. Resolves immediately.\r\n\r\nIf `wait` is given as `true`, then the chain will wait for the duration of one animation loop.\r\n\r\nFor example, this code:\r\n\r\n    chain:anim(\"ego\", \"throw dust\")\r\n    chain:wait(slime:animationDuration(\"ego\", \"throw dust\"))\r\n\r\ngives the same result as this line:\r\n\r\n    chain:anim(\"ego\", \"throw dust\", true)\r\n\r\n![func](api/func.png) `chain:floor (path)`  \r\n\r\nCalls `slime:floor`. Resolves immediately.\r\n\r\n![func](api/func.png) `chain:func (func, params)`  \r\n\r\nCalls the function `func` with the given parameters. Resolves immediately.\r\n\r\n![func](api/func.png) `chain:say (actor, words)`  \r\n\r\nCalls `slime:say`. Resolves when the given actor is not busy speaking. If `slime:skipSpeech` is called while the actor is talking, then this link will be resolved.\r\n\r\n![func](api/func.png) `chain:sound (source)`\r\n\r\nPlays the given audio source. Resolves immediately.\r\n\r\n### Example Chain\r\n\r\n    local chain = slime:chain()\r\n    chain:move(\"ego\", \"light switch\")\r\n    chain:anim(\"ego\", \"flip the switch\")\r\n    chain:image(\"light\", \"light-on.png\")\r\n    chain:sound(love.audio.newSource(\"sounds/switch.wav\", \"static\"))\r\n    chain:say(\"ego\", \"Now I can see\")\r\n\r\n\r\n## Cursors\r\n\r\n![func](api/func.png) `slime.setCursor (name, image, scale, hotx, hoty)`\r\n\r\nSet a hardware cursor with scale applied.\r\n\r\nWhen you set a cursor, the `name` is passed back as the `event` parameter to `slime.callback()`. This makes it easy to check if the player is using a key on a door.\r\n\r\nCall with no parameters to set the default cursor.\r\n\r\n## Settings\r\n\r\nSLIME offers these settings to customize your game:\r\n\r\n    slime.settings[\"status position\"] = 70      -- The Y position to print the built-in status text\r\n    slime.settings[\"status font\"] = love.graphics.Font\r\n    slime.settings[\"speech position\"] = 0       -- The Y position to print speech\r\n    slime.settings[\"speech font\"] = love.graphics.Font\r\n\r\n---\r\n\r\n# CODE SNIPPETS\r\n\r\n## Flip the frames on a custom animation\r\n\r\nThe `addAnimation` call returns the Anim8 object which has flip functions:\r\n\r\n    local myanim = slime:addAnimation(\"ego\", \"dig\", \"images/ego.png\", tileSize, tileSize, {\"22-25\", 1}, 0.2)\r\n    myanim:flipH()  -- flips horizontally\r\n    myanim:flipV()  -- flips vertically\r\n\r\n## One shot animations\r\n\r\nTo animate an actor once, like an opening door, hook into the Animation Looped callback:\r\n\r\n\r\n    function slime.animationLooped (actor, key, counter)\r\n        \r\n        -- Keep the door closed after the closing animation played.\r\n        if actor == \"door\" and key == \"closing\" then\r\n            slime:setAnimation (\"door\", \"closed\")\r\n        end\r\n        \r\n    end\r\n\r\nOf course this assume you have added a \"door\" actor with the \"closing\" and \"closed\" custom animations.\r\n\r\n---\r\n\r\n# LICENSE\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\nany later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program. If not, see http://www.gnu.org/licenses/.\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}